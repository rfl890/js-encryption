!async function(){const e="object"==typeof window,t=!e&&"object"==typeof process&&process.versions&&process.versions.node,r=!e&&"object"==typeof self&&self.postMessage,n="object"==typeof module&&module.exports,a="function"==typeof define&&define.amd,o=e&&window||r&&self,s=o&&o.crypto.subtle||t&&require("crypto").subtle;if(!s)throw new Error("It appears that your browser does not support the SubtleCrypto API. Please upgrade to a newer browser that supports it.");const i=new TextEncoder,y=i.encode("WebCrypto|AESKey"),c=i.encode("WebCrypto|HMACKey"),w=e=>null!=e;function l(...e){const t=[...e],r=t.reduce(((e,t)=>e+t.length),0),n=new Uint8Array(r);let a=0;return t.forEach((e=>{n.set(e,a),a+=e.length})),n}async function p(e,t){if(!w(e)||"string"!=typeof e)throw new TypeError("password must be a string");if(w(t)&&!(t instanceof Uint8Array))throw new TypeError("salt must be a Uint8Array");if(w(t)&&32!==t.length)throw new Error("salt.length must be 32");const r=i.encode(e),n=await crypto.subtle.digest("SHA-256",r.buffer),a=await crypto.subtle.importKey("raw",n,"PBKDF2",!1,["deriveBits"]),o=t||crypto.getRandomValues(new Uint8Array(32)),s={name:"PBKDF2",hash:"SHA-256",salt:o,iterations:6e5},y=await crypto.subtle.deriveBits(s,a,256);return{masterKey:await crypto.subtle.importKey("raw",y,"HKDF",!1,["deriveKey"]),salt:o}}async function h(e,t){if(!(e instanceof Uint8Array))throw new TypeError("keyData must be a Uint8Array");if(32!==e.length)throw new Error("keyData.length must be 32");if(w(t)&&!(t instanceof Uint8Array))throw new TypeError("salt must be a Uint8Array");if(w(t)&&32!==t.length)throw new Error("salt.length must be 32");const r=t||crypto.getRandomValues(new Uint8Array(32));return{masterKey:await crypto.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]),salt:r}}async function u(e,t){return{key_aes:await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:y},e,{name:"AES-CTR",length:256},!1,["encrypt","decrypt"]),key_hmac:await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:c},e,{name:"HMAC",hash:"SHA-256"},!1,["sign","verify"])}}async function f(e,t){if(!(w(e)&&e instanceof Uint8Array))throw new Error("data must be a Uint8Array");const{masterKey:r,salt:n}=await p(t),{key_aes:a,key_hmac:o}=await u(r,n),i=new Uint8Array(16);crypto.getRandomValues(i);const y=l(new Uint8Array(await s.encrypt({name:"AES-CTR",counter:i,length:64},a,e)),i,n);return l(y,new Uint8Array(await crypto.subtle.sign("HMAC",o,y)))}async function d(e,t){if(!(w(e)&&e instanceof Uint8Array))throw new Error("data must be a Uint8Array");if(e.length<80)throw new Error("Invalid ciphertext");const r=e.slice(0,e.length-32),n=e.slice(-32),a=e.slice(0,e.length-80),o=e.slice(a.length,e.length-64),s=e.slice(a.length+16,e.length-32),{masterKey:i}=await p(t,s),{key_aes:y,key_hmac:c}=await u(i,s);if(!0!==await crypto.subtle.verify("HMAC",c,n,r))throw new Error("Decryption error");try{return new Uint8Array(await crypto.subtle.decrypt({name:"AES-CTR",counter:o,length:64},y,a))}catch(e){throw new Error("Decryption error")}}async function A(e,t){if(!(w(e)&&e instanceof Uint8Array))throw new Error("data must be a Uint8Array");const{masterKey:r,salt:n}=await h(t),{key_aes:a,key_hmac:o}=await u(r,n),i=new Uint8Array(16);crypto.getRandomValues(i);const y=l(new Uint8Array(await s.encrypt({name:"AES-CTR",counter:i,length:64},a,e)),i,n);return l(y,new Uint8Array(await crypto.subtle.sign("HMAC",o,y)))}async function m(e,t){if(!(w(e)&&e instanceof Uint8Array))throw new Error("data must be a Uint8Array");if(!(w(t)&&t instanceof Uint8Array))throw new Error("key must be a Uint8Array");if(e.length<80)throw new Error("Invalid ciphertext");const r=e.slice(0,e.length-32),n=e.slice(-32),a=e.slice(0,e.length-80),o=e.slice(a.length,e.length-64),s=e.slice(a.length+16,e.length-32),{masterKey:i}=await h(t,s),{key_aes:y,key_hmac:c}=await u(i,s);if(!0!==await crypto.subtle.verify("HMAC",c,n,r))throw new Error("Decryption error");try{return new Uint8Array(await crypto.subtle.decrypt({name:"AES-CTR",counter:o,length:64},y,a))}catch(e){throw new Error("Decryption error")}}n?module.exports={encrypt:A,decrypt:m,encryptPassword:f,decryptPassword:d}:!e&&!r||a?a&&define((function(){return{encrypt:A,decrypt:m,encryptPassword:f,decryptPassword:d}})):o.js_encryption={encrypt:A,decrypt:m,encryptPassword:f,decryptPassword:d}}();