!function(){const e="object"==typeof window,t=!e&&"object"==typeof process&&process.versions&&process.versions.node,r=!e&&"object"==typeof self&&self.postMessage,n="object"==typeof module&&module.exports,a="function"==typeof define&&define.amd,o=e&&window||r&&self,s=o&&o.crypto.subtle||t&&require("crypto").subtle;if(!s)throw new Error("It appears that your browser does not support the SubtleCrypto API. Please upgrade to a newer browser that supports it.");const i=new TextEncoder,c=i.encode("WebCrypto|AESKey"),y=i.encode("WebCrypto|HMACKey"),l=e=>null!=e;function w(...e){const t=[...e],r=t.reduce(((e,t)=>e+t.length),0),n=new Uint8Array(r);let a=0;return t.forEach((e=>{n.set(e,a),a+=e.length})),n}async function p(e,t){if(!(e instanceof Uint8Array))throw new TypeError("keyData must be a Uint8Array");if(32!==e.length)throw new Error("keyData.length must be 32");if(l(t)&&!(t instanceof Uint8Array))throw new TypeError("salt must be a Uint8Array");if(l(t)&&32!==t.length)throw new Error("salt.length must be 32");const r=t||crypto.getRandomValues(new Uint8Array(32));return{masterKey:await crypto.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]),salt:r}}async function u(e,t){return{key_aes:await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:c},e,{name:"AES-CTR",length:256},!1,["encrypt","decrypt"]),key_hmac:await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:y},e,{name:"HMAC",hash:"SHA-256"},!1,["sign","verify"])}}async function h(e,t){const{masterKey:r,salt:n}=await async function(e){const t=i.encode(e),r=await crypto.subtle.digest("SHA-256",t.buffer),n=await crypto.subtle.importKey("raw",r,"PBKDF2",!1,["deriveBits"]),a=new Uint8Array(32);crypto.getRandomValues(a);const o={name:"PBKDF2",hash:"SHA-256",salt:a,iterations:6e5},s=await crypto.subtle.deriveBits(o,n,256);return{masterKey:await crypto.subtle.importKey("raw",s,"HKDF",!1,["deriveKey"]),salt:a}}(t),{key_aes:a,key_hmac:o}=await u(r,n),c=new Uint8Array(16);crypto.getRandomValues(c);const y=w(new Uint8Array(await s.encrypt({name:"AES-CTR",counter:c,length:64},a,e)),c,n);return w(y,new Uint8Array(await crypto.subtle.sign("HMAC",o,y)))}async function d(e,t){if(e.length<81)throw new Error("Invalid ciphertext");const r=e.slice(0,e.length-32),n=e.slice(-32),a=e.slice(0,e.length-80),o=e.slice(a.length,e.length-64),s=e.slice(a.length+16,e.length-32),{masterKey:c}=await async function(e,t){const r=i.encode(e),n=await crypto.subtle.digest("SHA-256",r.buffer),a=await crypto.subtle.importKey("raw",n,"PBKDF2",!1,["deriveBits"]),o={name:"PBKDF2",hash:"SHA-256",salt:t,iterations:6e5},s=await crypto.subtle.deriveBits(o,a,256);return{masterKey:await crypto.subtle.importKey("raw",s,"HKDF",!1,["deriveKey"])}}(t,s),{key_aes:y,key_hmac:l}=await u(c,s);if(!0!==await crypto.subtle.verify("HMAC",l,n,r))throw new Error("Decryption error");try{return new Uint8Array(await crypto.subtle.decrypt({name:"AES-CTR",counter:o,length:64},y,a))}catch(e){throw new Error("Decryption error")}}async function f(e,t){const{masterKey:r,salt:n}=await p(t),{key_aes:a,key_hmac:o}=await u(r,n),i=new Uint8Array(16);crypto.getRandomValues(i);const c=w(new Uint8Array(await s.encrypt({name:"AES-CTR",counter:i,length:64},a,e)),i,n);return w(c,new Uint8Array(await crypto.subtle.sign("HMAC",o,c)))}async function m(e,t){if(e.length<81)throw new Error("Invalid ciphertext");const r=e.slice(0,e.length-32),n=e.slice(-32),a=e.slice(0,e.length-80),o=e.slice(a.length,e.length-64),s=e.slice(a.length+16,e.length-32),{masterKey:i}=await p(t,s),{key_aes:c,key_hmac:y}=await u(i,s);if(!0!==await crypto.subtle.verify("HMAC",y,n,r))throw new Error("Decryption error");try{return new Uint8Array(await crypto.subtle.decrypt({name:"AES-CTR",counter:o,length:64},c,a))}catch(e){throw new Error("Decryption error")}}n?module.exports={encrypt:f,decrypt:m,encryptPassword:h,decryptPassword:d}:!e&&!r||a?a&&define((function(){return{encrypt:f,decrypt:m,encryptPassword:h,decryptPassword:d}})):o.js_encryption={encrypt:f,decrypt:m,encryptPassword:h,decryptPassword:d}}();